# org.alljoyn.FileTransfer version 1

## Theory of Operation

The org.alljoyn.FileTransfer interface provides a standardized mechanism 
for exchanging binary data between an AllJoyn consumer and an AllJoyn producer,
where the AllJoyn consumer needs to manage, or upgrade an AllJoyn producer.  
Files are typically large such as new firmware. It is also possible that data 
or large log files could be generated by a producer, and may need to be 
retrieved by an administrative consumer.

Currently, AllJoyn provides an alternative mechanism for transferring large 
amounts of data.  The BusAttachment object supports the "GetSessionFd()" API.
This method returns a file descriptor that can be used for data transfer when
a raw session is created. Note that a raw session is required to use the file 
descriptor returned by GetSessionFd() and GetSessionFd() does not conform to 
the AllJoyn security architecture as it is not called as part of a secure 
interface.
 
The org.alljoyn.FileTransfer interface performs file transfers by 
transferring files in binary chunks.  The chunk size cannot exceed the 
standard AllJoyn array limit, and varies depending on each AllJoyn producer's
needs.  For example, an AllJoyn producer might incorporate a flash memory
with a block size of 4096 bytes.  The producer could specify that the transfer
chunk size is the same as its natural block size.

AllJoyn producers that implement this interface may have the need to expose 
multiple files (generally expected to be less than 5).  To support this, an 
AllJoyn producer would create a Bus Object for each file.  For example, the foo
device could expose an object for upgrading its firmware by creating the 
org.alljoyn.FileTransfer interface on the \foo\firmware bus object, and could 
expose another object for upgrading its FPGA by creating the \foo\fpga bus 
object.

The org.alljoyn.FileTransfer interface permits one active read or write 
operation on a bus object per session.  For example, if a read operation is
started during a session on the \foo\firmware bus object, the next write or 
read operation in the same session can not start until the current read 
operation completes.  If desired, the producer that implements this interface 
may allow a separate concurrent session to start a concurrent read operation on
the same bus object.  However, no readers are permitted while any one
session is actively writing.  Likewise, no write may begin if any readers are
active.  

To perform a read operation, a consumer first calls the StartChunkRead method 
on a producer's bus object.  The producer returns the total length (Length) of
the data file, and the chunk size (ChunkSize) that will be used.  The consumer
repeatedly issues the ReadNextChunk method until Length bytes have been read 
from the producer.  The size of each buffer read by the ReadNextChunk method 
will be ChunkSize bytes except for the last invocation, which will only have 
the remaining bytes.  The file is guaranteed to be delivered sequentially.  For 
example, if the ChunkSize is 4096 and the Length is 8193, the first invocation 
of ReadNextChunk delivers 4096 bytes from file offset 0-4095, the second 
invocation of ReadNextChunk delivers 4096 bytes from file offset 4096-8191, and
the final invocation of ReadNextChunk delivers 1 byte from file offset 8192. 
The file offset is not exchanged and is internally tracked by the both the
consumer and producer.

To perform a write operation, a consumer first calls the StartChunkWrite method
on a producer's bus object.  The consumer passes the total length (Length) of
the data file to the producer and the producer returns the chunk size 
(ChunkSize) that should be used during the transfer.  The consumer,
repeatedly issues the WriteNextChunk method until Length bytes have been 
written to the producer.  The size of each buffer written by the WriteNextChunk 
method will be ChunkSize bytes except for the last invocation, which will only 
have the remaining bytes.  The consumer must deliver the file sequentially, 
waiting for each WriteNextChunk method call to return.  For example, if the 
ChunkSize is 4096 and the Length is 8193, the first invocation of 
WriteNextChunk delivers 4096 bytes from file offset 0-4095, the second 
invocation of WriteNextChunk delivers 4096 bytes from file offset 4096-8191, 
and the final invocation of WriteNextChunk delivers 1 byte from file offset 
8192. The file offset is not exchanged and is internally tracked by both the
consumer and producer.

In the event that a write operation fails there is no means to resume the
write operation.  A full resend by the consumer is required.  The producer
should disregard all data written.  The producer should also implement measures
that ensure a failed write does not compromise operational integrity.
For example, writing new firmware to a device should be performed in such a
way that the firmware is written to a temporary buffer, and then swapped into
place during the final and successful WriteNextChunk invocation.  It should not
overwrite the existing firmware as a failed transfer would leave the firmware
in an invalid state.

In the event that a session is lost during a transfer, the producer must 
release any resources acquired during the transfer.  For example, if a data
file was locked for read, then the file should be released.  If a temporary
file was created for write, then the temporary file should be deleted.

To mitigate Denial-of-Service attacks, the producer should incoporate a 
Transfer Progress Timer.  The purpose of the timer is to ensure that the
consumer advances a transfer at a reasonable pace.  The producer starts the
timer when either the StartChunkRead or StartChunkWrite methods are 
successfully called by the consumer.  If ReadNextChunk or WriteNextChunk are 
not called before the timer expires, then the producer should assume the 
transfer was aborted.  At the conclusion of each successful ReadNextChunk or
WriteNextChunk the timer should be reset.  The time should be long enough to 
allow sufficient time for a consumer to process a chunk of data, but short
enough to prevent the producer from starving other consumers of a producers
resources.


## Specification

|                       |                                               |
|-----------------------|-----------------------------------------------|
| Version               | 1                                             |
| Annotation            | org.alljoyn.Bus.Secure = true                 |

### Properties

#### Version

|            |                                                          |
|------------|----------------------------------------------------------|
| Type       | uint16                                                   |
| Access     | read-only                                                |
| Annotation | org.freedesktop.DBus.Property.EmitsChangedSignal = true  |

The interface version number.

#### MaxWriteLength

|            |                                                          |
|------------|----------------------------------------------------------|
| Type       | uint32                                                   |
| Access     | read-only                                                |
| Annotation | org.freedesktop.DBus.Property.EmitsChangedSignal = true  |

The total amount of write space available in bytes.


### Methods

#### StartChunkWrite([in] length, [out] chunkSize)

Begins a file write operation with a service.  Calling this again from 
the current session before writing all data restarts the write operation.

Input arguments:

  * length --- uint32 --- number of total file bytes to write to the producer
  
Output arguments:

  * chunkSize --- uint32 --- the maximum chunk transfer size in bytes.  This 
    cannot exceed the maximum alljoyn array size and is typically (but not 
    required to be) the producer service's non-volatile storage allocation unit 
    size (e.g., 512, 1024, 2048, 4096 etc.).  This value must also be greater 
    than 0.

Errors returned by this method:

 * org.alljoyn.FileTransfer.Error.NotSupported
   If write operation is not supported.
   
 * org.alljoyn.FileTransfer.Error.PermissionDenied
   If another read or write operation is already in progress.
   
 * org.alljoyn.FileTransfer.Error.OpenFailed
   If file could not be created or opened for write.
   
 * org.alljoyn.FileTransfer.Error.LengthInvalid
   If length argument is 0.
   
 * org.alljoyn.FileTransfer.Error.LengthTooLarge
   If length argument is too large for the destination device. See 
   MaxWriteLength property.
   

#### WriteNextChunk([in] buffer)

Writes a chunk sized (or less) data buffer to a producer.  This method should 
be repeatedly called with a new buffer of data until all bytes are copied.

Input arguments:

  * buffer --- uint8[] --- the byte array of data to write to the producer
    not greater than the chunk size established by the StartChunkWrite method.

Errors returned by this method:
      
  * org.alljoyn.FileTransfer.Error.WriteFailed
    If file could not be written.  This error ends the current write transfer.

  * org.alljoyn.FileTransfer.Error.WriteNotStarted
    No write operation is in progress for current session, or if a transfer has
    already finished.    

  * org.alljoyn.FileTransfer.Error.BufferTooLarge
    The buffer length passed was larger than the chunk size. This error ends 
    the current write transfer.
    
  * org.alljoyn.FileTransfer.Error.TooMuchData
    The number of bytes passed was greater than the remaining bytes to write. 
    This error ends the current write transfer.

#### StartChunkRead([out] length, [out] chunkSize)

Begins a file read operation with a producer.  Calling this again from the
same session before reading all bytes, restarts the read operation.

Output arguments:

  * length --- uint32 --- number of total bytes of file to read.
  
  * chunkSize --- uint32 --- the maximum chunk transfer size in bytes.  This 
    cannot exceed the maximum alljoyn array size and is typically (but not 
    required to be) the producer service's non-volatile storage allocation unit
    size (e.g., 512, 1024, 2048, 4096 etc.).  This value must also be greater 
    than 0.

Errors returned by this method:
  
 * org.alljoyn.FileTransfer.Error.PermissionDenied
   If a write operation is already in progress.  This may also be returned if
   a read operation is already in progress and multiple readers are not 
   allowed by the implementation.
   
 * org.alljoyn.FileTransfer.Error.OpenFailed
   If file could not be opened for read.


#### ReadNextChunk([out] buffer)

Reads a chunk sized (or less) chunk of data from a producer.  This method should 
be repeatedly called until all bytes are received from the producer.

Output arguments:

  * buffer --- uint8[] --- chunk sized or less array of bytes from the
    producer. 

Errors returned by this method:
   
  * org.alljoyn.FileTransfer.Error.ReadFailed
    If file could not be read.   This error ends the current read transfer.

  * org.alljoyn.FileTransfer.Error.ReadNotStarted
    Indicates that all bytes have already been returned to the caller or that
    a read has never been started for the current session.
    
### Signals

None

## References

For the corresponding Introspection XML, refer to: FileTransfer-v1.xml
